{"name":"Psmm","tagline":"PSeudo-Mutable Message for Actors","body":"## Project developing progress:\r\nGeneral tests passed, so far actors work fine, but there are still a bunch of flaws. Now I'm working hard on refactoring and refining. Hope those of you who're interested could contribute to this project, and enlighten me.\r\n\r\n- [x] Most coding work.\r\n- [x] Javadoc.\r\n- [x] Actor simulation test.\r\n- [x] Refining and test.\r\n- [x] Simple usage description.\r\n- [x] Detailed document.\r\n- [x] Performance description.\r\n- [x] Release.\r\n- [ ] More necessary description and additional doc.\r\n- [ ] Next version.\r\n\r\n## What is Psmm?\r\nPsmm is the abbreviation for PSeudo-Mutable Message. It's a java library for [actors](https://en.wikipedia.org/wiki/Actor_model) that allows for creating and accessing immutable messages as if they were mutable ones.\r\n\r\nMessages are passed on from actors to actors, thus probably shared by threads. [Akka](http://akka.io/) document clearly states that messages must be immutable, otherwise Akka actors can't ensure eliminating evils of low level java concurrency. But for writing immutable object, you need to be careful about things. In this note, I wrote Psmm, so we can easily generate immutable message.\r\n\r\n## Getting started:\r\nFirst needing to initiate PsmmSystem:\r\n```java\r\n\t\tPsmmSystem.initiate(); //only invoke once in your main thread\r\n```\r\nCreating a new message\r\n```java\r\n\t\tUMessage message = \r\n\t\t\t\tMessages.builder() //get builder\r\n\t\t\t\t.set(key1, value1) \r\n\t\t\t\t.set(key2, value2) //add some data\r\n\t\t\t\t...\r\n\t\t\t\t.build(); \r\n```\r\nModifying an existed one:\r\n```java\r\n\t\tUMessage messageAfter = \r\n\t\t\t\tmessageBefore \r\n\t\t\t\t.set(key1, value1) \r\n\t\t\t\t.set(key2, value2) //add or reset some data\r\n\t\t\t\t...\r\n\t\t\t\t.build(); \r\n```\r\nRegressing a message:\r\n```java\r\n\t\tUMessage message3 =message2.regress();\r\n```\r\nRegression is very useful when actors work in pipeline, e.g. actor can simply check and regress a message to redo rather than resend one. \r\n\r\nCode example:\r\n```java\r\nimport com.github.cuzfrog.psmm.Messages;\r\nimport com.github.cuzfrog.psmm.PsmmSystem;\r\nimport com.github.cuzfrog.psmm.UMessage;\r\n\r\nclass SimpleTest {\r\n\r\n\t@SuppressWarnings(\"boxing\")\r\n\tpublic static void main(String[] args) {\r\n\t\t// TODO Auto-generated method stub\r\n\r\n\t\tPsmmSystem.initiate(); //only invoke once in your main thread\r\n\t\t\r\n\t\t\r\n\t\t//create a new message:\r\n\t\tString key1 = \"int1\";\r\n\t\tString key2 = \"int2\";\r\n\t\tString key3 = \"str1\";\r\n\t\tUMessage message1 = \r\n\t\t\t\tMessages.builder() //get builder\r\n\t\t\t\t.set(key1, 2)\r\n\t\t\t\t.set(key2, 122)\r\n\t\t\t\t.set(key3, \"this is string\") //add some data\r\n\t\t\t\t.build(); //without build() compile time error.\r\n\t\t//after passed to another actor, fetch data:\r\n\t\tSystem.out.println(message1.get(key1) \r\n\t\t\t\t+ \"|\" + message1.get(key2) \r\n\t\t\t\t+ \"|\" + message1.get(key3));\r\n\t\t//result: 2|122|this is string\r\n\t\t\r\n\t\tString key4 = \"double1\";\r\n\t\t//\"modify\" last message, reset some data, add some new data:\r\n\t\tUMessage message2 =\r\n\t\t\t\tmessage1\r\n\t\t\t\t.set(key2, 45)\r\n\t\t\t\t.set(key3, \"this is another string\")\r\n\t\t\t\t.set(key4, 568.3d)\r\n\t\t\t\t.build();\r\n\t\t//after passed to another actor, fetch data:\r\n\t\tSystem.out.println(message2.get(key1) \r\n\t\t\t\t+ \"|\" + message2.get(key2) \r\n\t\t\t\t+ \"|\" + message2.get(key3)\r\n\t\t\t\t+ \"|\" + message2.get(key4));\r\n\t\t//result: 2|45|this is another string|568.3\r\n\t\t\r\n\t\tUMessage message3 =message2.regress();\r\n\t\tif(message3!=null){\r\n\t\t\tSystem.out.println(message3.get(key1) \r\n\t\t\t\t\t+ \"|\" + message3.get(key2) \r\n\t\t\t\t\t+ \"|\" + message3.get(key3)\r\n\t\t\t\t\t+ \"|\" + message3.get(key4));\r\n\t\t}\r\n\t\t//result: 2|122|this is string|null\r\n\t}\r\n}\r\n```\r\nUsing typed message (others are the same):\r\n```java\r\n\tTBuilder<String, Integer> b2 = Messages.typedBuilder();\r\n\tTMessage<String, Integer> message2 = b2.set(\"key1\", 583)\r\n\t\t\t\t// .set(\"key2\", \"string value\") //compile time error\r\n\t\t\t\t.build();\r\n```\r\n_NOTE:When use typed message, you must ensure type's immutability._\r\n\r\n**Anti-patterns:** Be careful!\r\n```java\r\n//now you received a message.\r\nmessage.set(\"key1\", 583).set(\"key2\", 1773).build();  //you think you updated it.\r\n//then send the message. ERROR, the message you sent is not the new one\r\n\r\n//right version - must give a new reference:\r\nUMessage newMessage=message.set(\"key1\", 583).set(\"key2\", 1773).build(); \r\n//or use the old reference:\r\nmessage=message.set(\"key1\", 583).set(\"key2\", 1773).build(); \r\n```\r\n\r\n\r\n## Document\r\n####Introduction\r\nPsmm messages take advantage of Decorator Pattern. Every message has a reference of preceded message. For newly created message, PsmmFactory puts a RootMessage in it. After a message has been set(\"modified\"), factory create a new message decorating the old one, of course, with new data. Therefore, you can access psmm as if it were mutable.\r\n\r\n_For class info, please see source file._\r\n\r\n\r\n####Styles\r\nPsmm includes different *Styles of messages standing for different structures.\r\n\r\nA1. **Linked**(default): decorate old message when every setting. When getting data, first check keys in newest message, then the last one. This is the fast way to create new object, because when you create it, you don't care about the old data.But when the chain is long, it'll be slower to fetch some data. It also provides a way to regress a message: shell the outermost message, return the inner one.\r\n\r\nA2. **Flat**: no decoration, read data from old message and merge them into new message.\r\n\r\nB1. Typed: need to explicitly indicate Generic parameter Type. Thus gives flexibility to put user defined data object into message.\r\n\r\nB2. **Untyped**: only takes basic immutable object, such as String, Integer etc. When retrieving data, need to cast.\r\n\r\nC. Retained(deprecated): references of messages created are stored in a pool. Why not reuse immutable object? (_But there might be a pitfall, is it really necessary to retain small object in modern JVM? Generally speaking, this is a bad idea and likely to cause other undesirable potential problems. For now I deprecated this feature. All message will be newly created._)\r\n\r\nD1. **Value**: One message equals another depending on their values that they exhibit.\r\n\r\nD2. **Unique** (default): No override to equals() method, message only equals itself.\r\n\r\n_The word *Style is used for distinguishing from Parameter Type._\r\n\r\nHow to choose style:\r\n```java\r\nMessages.builder(Messages.Style.FLAT_MAP)\r\n```\r\n\r\n####Builder and Factory model\r\n* **Builder**(Originally called raw message) is a concept helper class which is exposed to user instead of a factory, and to ensure message is actually created. It's a [Proxy](https://en.wikipedia.org/wiki/Proxy_pattern) of a factory. Consider situation below:\r\n```java\r\nUMessage message2 =\r\n\t\tmessage1\r\n\t\t.set(key2, 45)  //when first call set(), it turns to a raw message\r\n\t\t.set(key3, \"this is another string\")\r\n\t\t.set(key4, 568.3d)\r\n\t\t//.build(); //no message is really created. Type mismatch, compile time error.\r\n```\r\nA builder cannot evaluate to UMessage. Also, in concept, it's better than return a factory object.\r\n\r\n* **Factory** do the real job to store user data and create message. It utilizes the [Builder Pattern](https://en.wikipedia.org/wiki/Builder_pattern). Factory has a final reference of raw message, which means they're paired when their instance are created. The reason to do so is because only factories are store in Factory Pool.\r\n\r\n####Factory detail\r\n* **Module** is factory's component class, does concrete job inside factory. In this [Strategy Pattern](https://en.wikipedia.org/wiki/Strategy_pattern), same factory can be used to create different styles of message. Modules are thread safe or state less, so several factories are able to reuse same Module instances. Modules are created once when PsmmSystem initiates and stored into an EnumMap. When needed, they are dynamically assembled into factory calling them. If a factory is about to create a second message with the same Style as the last one, module inside will not change which avoids module-map re-searching. Hence better performance with consistent Style throughout your application.\r\n\r\nThere are three kinds of Modules:\r\n\r\n1. Creation: creates concrete message, like CachedMessage or UncachedMessage.\r\n\r\n2. Data: designates Data implementation into factory, like HashMap.\r\n\r\n3. Structure: decides which style, like Flat or Linked.\r\n\r\n\r\nModules work in combine, taking advantage of [Decorator Pattern](https://en.wikipedia.org/wiki/Decorator_pattern).\r\n\r\n* **Factory Pool** stores created factories in it, which implements a ThreadLocal<PsmmFactory> to attach a new factory instance to every thread.  When fetching factory, module is assembled into factory according to message's style. \r\n\r\n* **Data** class to encapsulate concrete data store strategy. Now, there's only MapData that implements HashMap. Factory has a Data inside, when create message, it give that Data to message and ditch the Data's reference.\r\n\r\n####PsmmSystem and helper Messages\r\n* **PsmmSystem** holds instances of factory pool, message pool and initiate Modules, internally provide static methods.  Instantiating Module at runtime gives more flexibility.\r\n* **Messages** provides factory methods to create message.\r\n\r\n####Configuration\r\nPsmm provides a class PsmmConfiguration to do some custom setup when initiation. Later I shall probably provide way to customize factory Module and Data through configuration.\r\n\r\nHow to setup:\r\n```java\r\nPsmmConfiguration config=new PsmmConfiguration()\r\n\t\t\t.setFactoryPoolChoseType(FactoryPoolType.NULL) //no factory pooling\r\n\t\t\t...\r\nPsmmSystem.initiate(config);\r\n```\r\n\r\n####Performance\r\nI've prepared some performance test data, and I'll upload them, and explain in detail.\r\n\r\n**1. creating new message and set one pair of data with factory pooled:(20 rounds warm up and tests)**\r\n\r\nBenchmark        |         Mode | Cnt  |  Score  | Error | Units\r\n------------ | ------------- | ------------- | -------------  | -------------  | -------------  \r\ntestCreateControlMessage | avgt  | 20 | 237.161 | ± 0.889 | ns/op\r\ntestCreateTypedFlat    |   avgt  | 20 | 174.108 | ± 3.171 | ns/op\r\ntestCreateTypedLinked  |   avgt  | 20 | 179.215 | ± 3.695 | ns/op\r\ntestCreateUntypedFlat  |   avgt  | 20 | 175.835 | ± 2.523 | ns/op\r\ntestCreateUntypedLinked  | avgt  | 20 | 172.466 | ± 1.766 | ns/op\r\n\r\n\r\n_Tested with jmh: 10-20 warmups, 10-20 rounds, 8 threads. Tests simple create a new message and set a pair of random key and Integer. Control message(immutable) is created via two HashMaps, one as temporary data vehicle when creating, another as data field. HW: xeon E3 1230v2, 16G DDR3 1600. OS: Windows, Oracle JDK 1.8.0_51. See source file for more detail._\r\n\r\n\r\nIt's very important to know that generating message, in most cases, only takes a fraction of application time. Sometimes, it's really not necessary to worry about their performance. When I did micro-benchmark test, yeah, disparity could be huge. However, when I did actual actor interaction test, performances are in the same scale.\r\n\r\n\r\n####Javadoc\r\nI have written complete javadoc.\r\n\r\n## Support or Contact\r\nAuthors:Cause Chung (@cuzfrog)\r\n\r\nAny problem, please hit me on GitHub or mail me: cuzfrog@139.com / cuzfrog@gamil.com\r\n\r\n## License\r\nThe MIT License (MIT)","google":"UA-67181335-1","note":"Don't delete this file! It's used internally to help with page regeneration."}