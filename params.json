{"name":"Psmm","tagline":"PSeudo-Mutable Message for Actors","body":"## Project developing progress:\r\nGeneral tests passed, so far actors work fine, but there are still bunch of flaws. Now I'm working hard on refactoring and refining. Hope those of you who're interested could contribute to this project, and enlighten me.\r\n\r\n- [x] Most coding work.\r\n- [x] Actor simulation test.\r\n- [ ] Snapshot jar.\r\n- [ ] Refining and test.\r\n- [x] Simple usage description.\r\n- [ ] Detailed description.\r\n- [ ] Upload javadoc and performance report.\r\n- [ ] Release.\r\n\r\n## What is Psmm?\r\nPsmm is the abbreviation for PSeudo-Mutable Message. It's a java library for [actors](https://en.wikipedia.org/wiki/Actor_model) that allows for creating and accessing immutable messages as if they were mutable ones.\r\n\r\nMessages are passed on from actors to actors, thus probably shared by threads. [Akka](http://akka.io/) document clearly states that messages must be immutable, otherwise Akka actors can't ensure eliminating evils of low level java concurrency. But for writing immutable object, you need to be careful about things. In this note, I wrote Psmm, so we can easily generate immutable message.\r\n\r\n## Getting started:\r\nFirst needing to initiate PsmmSystem:\r\n```java\r\n\t\tPsmmSystem.initiate(); //only invoke once in your main thread\r\n```\r\nCreating a new message\r\n```java\r\n\t\tUMessage message = \r\n\t\t\t\tMessages.create() //create a raw message\r\n\t\t\t\t.set(key1, value1) \r\n\t\t\t\t.set(key2, value2) //add some data\r\n\t\t\t\t...\r\n\t\t\t\t.cook(); \r\n```\r\nModifying an existed one:\r\n```java\r\n\t\tUMessage messageAfter = \r\n\t\t\t\tmessageBefore \r\n\t\t\t\t.set(key1, value1) \r\n\t\t\t\t.set(key2, value2) //add or reset some data\r\n\t\t\t\t...\r\n\t\t\t\t.cook(); \r\n```\r\nRegressing a message:\r\n```java\r\n\t\ttry {\r\n\t\t\tUMessage message3=message2.regress();\r\n\t\t} catch (PsmmCannotRegressExeption e) {\r\n\t\t\t//tell actor message only has one level\r\n\t\t}\r\n```\r\nRegression is very useful when actors work in pipeline, e.g. actor can simply check and regress a message to redo rather than resend one. \r\n\r\nCode example:\r\n```java\r\nimport cuz.my.psmm.Messages;\r\nimport cuz.my.psmm.PsmmSystem;\r\nimport cuz.my.psmm.UMessage;\r\n\r\nclass SimpleTest {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\t// TODO Auto-generated method stub\r\n\r\n\t\tPsmmSystem.initiate(); //only invoke once in your main thread\r\n\t\t\r\n\t\t\r\n\t\t//create a new message:\r\n\t\tString key1 = \"int1\";\r\n\t\tString key2 = \"int2\";\r\n\t\tString key3 = \"str1\";\r\n\t\tUMessage message1 = \r\n\t\t\t\tMessages.create() //create a raw message\r\n\t\t\t\t.set(key1, 2)\r\n\t\t\t\t.set(key2, 122)\r\n\t\t\t\t.set(key3, \"this is string\") //add some data\r\n\t\t\t\t.cook(); //without cook() compile time error.\r\n\t\t//after passed to another actor, fetch data:\r\n\t\tSystem.out.println(message1.get(key1) \r\n\t\t\t\t+ \"|\" + message1.get(key2) \r\n\t\t\t\t+ \"|\" + message1.get(key3));\r\n\t\t//result: 2|122|this is string\r\n\t\t\r\n\t\tString key4 = \"double1\";\r\n\t\t//\"modify\" last message, reset some data, add some new data:\r\n\t\tUMessage message2 =\r\n\t\t\t\tmessage1\r\n\t\t\t\t.set(key2, 45)\r\n\t\t\t\t.set(key3, \"this is another string\")\r\n\t\t\t\t.set(key4, 568.3d)\r\n\t\t\t\t.cook();\r\n\t\t//after passed to another actor, fetch data:\r\n\t\tSystem.out.println(message2.get(key1) \r\n\t\t\t\t+ \"|\" + message2.get(key2) \r\n\t\t\t\t+ \"|\" + message2.get(key3)\r\n\t\t\t\t+ \"|\" + message2.get(key4));\r\n\t\t//result: 2|45|this is another string|568.3\r\n\t\t\r\n\t\tUMessage message3 = null;\r\n\t\ttry {\r\n\t\t\tmessage3=message2.regress();\r\n\t\t} catch (PsmmCannotRegressExeption e) {\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t\tSystem.out.println(message3.get(key1) \r\n\t\t\t\t+ \"|\" + message3.get(key2) \r\n\t\t\t\t+ \"|\" + message3.get(key3)\r\n\t\t\t\t+ \"|\" + message3.get(key4));\r\n\t\t//result: 2|122|this is string|null\r\n\t}\r\n\r\n}\r\n```\r\nUsing typed message (others are the same):\r\n```java\r\n\t\tTMessage<Integer> message2=\r\n\t\t\t\tMessages.create(Integer.class)\r\n\t\t\t\t.set(\"key1\", 583)\r\n\t\t\t\t//.set(\"key2\", \"string value\") //compile time error\r\n\t\t\t\t.cook();\r\n```\r\n_NOTE:When use typed message, you must ensure type's immutability._\r\n\r\n## Document\r\n####Introduction\r\nPsmm messages take advantage of Decorator Pattern. Every message has a reference of preceded message. For newly created message, PsmmFactory puts a RootMessage in it. After a message has been set(\"modified\"), factory create a new message decorating the old one, of course, with new data. Therefore, you can access psmm as if it's mutable.\r\n\r\n_For class info, please see source file._\r\n\r\n\r\n####Styles\r\nPsmm includes different *Styles of messages standing for different structures.\r\n\r\nA1. **Linked**(default): decorate old message when every setting. When getting data, first check keys in newest message, then the last one. This is the fast way to create new object, because when you create it, you don't care about the old data.But when the chain is long, it'll be slower to fetch some data. It also provides a way to regress a message: shell the outermost message, return the inner one.\r\nA2. **Flat**: no decoration, read data from old message and merge them into new message.\r\nB1. Typed: need to explicitly indicate Generic parameter Type. Thus gives flexibility to put user defined data object into message.\r\nB2. **Untyped**: only takes basic immutable object, such as String, Integer etc. When retrieving data, need to cast.\r\nC1. **Retained**: references of messages created are stored in a pool. Why not reuse immutable object? (_But there might be a pitfall, is it really necessary to cache small object in modern JVM? I'm working on this issue and refactoring this algorithm. Generally speaking, this is a bad idea and likely to cause other undesirable potential problems. What I'm thinking about is there should be some situation where pool._)\r\nC2. **Free**(default): Oppose to Retained.\r\nD1. **Value** (not available now): One message equals another depending on their values.\r\nD2. **Unique** (not available now): No override to equals() method, message only equals itself.\r\n\r\n_The word *Style is used for distinguishing from Parameter Type._\r\n\r\nHow to choose style:\r\n```java\r\nMessages.create(Messages.Style.FLAT_MAP)\r\n```\r\n\r\n####Raw Message and Factory model\r\n* **Raw Message** is a concept helper class which is exposed to user instead of a factory, and to ensure message is actually created. It's a [Proxy](https://en.wikipedia.org/wiki/Proxy_pattern) of a factory. Consider situation below:\r\n```java\r\nUMessage message2 =\r\n\t\tmessage1\r\n\t\t.set(key2, 45)  //when first call set(), it turns to a raw message\r\n\t\t.set(key3, \"this is another string\")\r\n\t\t.set(key4, 568.3d)\r\n\t\t//.cook(); //no message is really created. Type mismatch, compile time error.\r\n```\r\nA raw message cannot evaluate to UMessage. Also, in concept, it's better than return a factory object.\r\nThere are two interfaces of raw message: UntypedRawMessage, TypedRawMessage<T>\r\n\r\n_It's not necessary to grab a raw message's reference in most cases._\r\n\r\n* **Factory** do the real job to store user data and create message. It utilizes the (Builder Pattern)[https://en.wikipedia.org/wiki/Builder_pattern]. Factory has a final reference of raw message, which means they're paired when their instance are created. The reason to do so is because only factories are store in Factory Pool.\r\n\r\n####Factory detail\r\n* **Module** is factory's component class, does concrete job inside factory. In this [Strategy Pattern](https://en.wikipedia.org/wiki/Strategy_pattern), same factory can be used to create different styles of message. Modules are thread safe or state less, so several factories are able to assemble same Module instances.\r\n\r\nThere are three kinds of Modules:\r\n1. Creation: creates concrete message, like CachedMessage or UncachedMessage.\r\n2. Data: designates Data implementation into factory, like HashMap.\r\n3. Structure: decides which style, like Flat or Linked.\r\n\r\nModules work in combine, taking advantage of [Decorator Pattern](https://en.wikipedia.org/wiki/Decorator_pattern).\r\n\r\n* **Factory Pool** stores created factories in it. The concrete factory pool MapFactoryPool implements a ConcurrentHashMap<ThreadId,PsmmFactory>. Since thread id is unique (at one time in one JVM), fetching factory in actors is efficient(While there is an unattested debate that cost of pooling and retrieving factories is less than create new factories?). When fetching factory, module is assembled into factory according to message's style. \r\n\r\n* **Data** class to encapsulate concrete data store strategy. Now, there's only MapData that implements HashMap. Factory has a Data inside, when create message, it give that Data to message and ditch the Data's reference.\r\n\r\n####PsmmSystem and helper Messages\r\n* **PsmmSystem** holds instances of factory pool, message pool and initiate Modules, internally provide static methods.  Instantiating Module at runtime gives more flexibility.\r\n* **Messages** provides factory methods to create message.\r\n\r\n####Configuration\r\nPsmm provides a class PsmmConfiguration to do some custom setup when initiation. Later I shall probably provide way to customize factory Module and Data through configuration.\r\n\r\nHow to setup:\r\n```java\r\n\t\tPsmmConfiguration config=new PsmmConfiguration()\r\n\t\t\t\t\t\t.setMessagePoolSize(6000)\r\n\t\t\t\t\t\t.setFactoryPoolSize(24)\r\n\t\t\t\t\t\t...\r\n\t\tPsmmSystem.initiate(config);\r\n```\r\n\r\n####Performance\r\nI've prepared some performance test data, and I'll upload them, and explain in detail.\r\n\r\nIt's very important to know that generating message, in most cases, only takes a fraction of application time. Sometimes, it's really not necessary to worry about their performance. When I did micro-benchmark test, yeah, disparity could be huge. However, when I did actual actor interaction test, performances are in the same scale.\r\n\r\n\r\n####Javadoc\r\nI have written complete javadoc.\r\n\r\n## Support or Contact\r\nAuthors:Cause Chung (@cuzfrog)\r\n\r\nAny problem, please hit me on GitHub or mail me: cuzfrog@139.com / cuzfrog@gamil.com\r\n\r\n## License\r\nThe MIT License (MIT)","google":"UA-67181335-1","note":"Don't delete this file! It's used internally to help with page regeneration."}