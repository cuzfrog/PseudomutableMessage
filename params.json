{"name":"Psmm","tagline":"PSeudo-Mutable Message for Actors","body":"## Project developing progress:\r\nGeneral tests passed, so far actors work fine. Now I'm working hard on refactoring and refining. Hope those of you who're interested could contribute to this project.\r\n\r\n- [x] Most coding work.\r\n- [x] Actor simulation test.\r\n- [ ] Snapshot jar.\r\n- [ ] Refining and test.\r\n- [x] Simple usage description.\r\n- [ ] Detailed description.\r\n- [ ] Upload javadoc and performance report.\r\n- [ ] Release.\r\n\r\n## What is Psmm?\r\nPsmm is abbreviation for PSeudo-Mutable Message. It's a java library for [actors](https://en.wikipedia.org/wiki/Actor_model) that allows to create and access immutable messages as if they were mutable ones.\r\n\r\nMessages are passed on from actors to actors, thus probably shared by threads. [Akka](http://akka.io/) document clearly states that messages must be immutable, otherwise Akka actors can't ensure eliminating evils of low level java concurrency. But for writing immutable object, you need to be careful about things. In this note, I wrote Psmm, so we can easily generate immutable message.\r\n\r\n## Get started:\r\nFirst initiate PsmmSystem(create factories and so on):\r\n```java\r\n\t\tPsmmSystem.initiate(); //only invoke once in your main thread\r\n```\r\nCreate a new message\r\n```java\r\n\t\tUMessage message = \r\n\t\t\t\tMessages.create() //create a raw message\r\n\t\t\t\t.set(key1, value1) \r\n\t\t\t\t.set(key2, value2) //add some data\r\n\t\t\t\t...\r\n\t\t\t\t.cook(); \r\n```\r\nModify an existed one:\r\n```java\r\n\t\tUMessage messageAfter = \r\n\t\t\t\tmessageBefore \r\n\t\t\t\t.set(key1, value1) \r\n\t\t\t\t.set(key2, value2) //add or reset some data\r\n\t\t\t\t...\r\n\t\t\t\t.cook(); \r\n```\r\nRegress a message:\r\n```java\r\n           try {\r\n\t\t\tUMessage message3=message2.regress();\r\n\t\t} catch (PsmmCannotRegressExeption e) {\r\n\t\t\t//tell actor message only has one level\r\n\t\t}\r\n```\r\nCode example:\r\n```java\r\nimport cuz.my.psmm.Messages;\r\nimport cuz.my.psmm.PsmmSystem;\r\nimport cuz.my.psmm.UMessage;\r\n\r\nclass SimpleTest {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\t// TODO Auto-generated method stub\r\n\r\n\t\tPsmmSystem.initiate(); //only invoke once in your main thread\r\n\t\t\r\n\t\t\r\n\t\t//create a new message:\r\n\t\tString key1 = \"int1\";\r\n\t\tString key2 = \"int2\";\r\n\t\tString key3 = \"str1\";\r\n\t\tUMessage message1 = \r\n\t\t\t\tMessages.create() //create a raw message\r\n\t\t\t\t.set(key1, 2)\r\n\t\t\t\t.set(key2, 122)\r\n\t\t\t\t.set(key3, \"this is string\") //add some data\r\n\t\t\t\t.cook(); //without cook() compile time error.\r\n\t\t//after passed to another actor, fetch data:\r\n\t\tSystem.out.println(message1.get(key1) \r\n\t\t\t\t+ \"|\" + message1.get(key2) \r\n\t\t\t\t+ \"|\" + message1.get(key3));\r\n\t\t//result: 2|122|this is string\r\n\t\t\r\n\t\tString key4 = \"double1\";\r\n\t\t//\"modify\" last message, reset some data, add some new data:\r\n\t\tUMessage message2 =\r\n\t\t\t\tmessage1\r\n\t\t\t\t.set(key2, 45)\r\n\t\t\t\t.set(key3, \"this is another string\")\r\n\t\t\t\t.set(key4, 568.3d)\r\n\t\t\t\t.cook();\r\n\t\t//after passed to another actor, fetch data:\r\n\t\tSystem.out.println(message2.get(key1) \r\n\t\t\t\t+ \"|\" + message2.get(key2) \r\n\t\t\t\t+ \"|\" + message2.get(key3)\r\n\t\t\t\t+ \"|\" + message2.get(key4));\r\n\t\t//result: 2|45|this is another string|568.3\r\n\t\t\r\n\t\tUMessage message3 = null;\r\n\t\ttry {\r\n\t\t\tmessage3=message2.regress();\r\n\t\t} catch (PsmmCannotRegressExeption e) {\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t\tSystem.out.println(message3.get(key1) \r\n\t\t\t\t+ \"|\" + message3.get(key2) \r\n\t\t\t\t+ \"|\" + message3.get(key3)\r\n\t\t\t\t+ \"|\" + message3.get(key4));\r\n\t\t//result: 2|122|this is string|null\r\n\t}\r\n\r\n}\r\n```\r\n## Document:\r\n####Introduction\r\nPsmm messages take advantage of Decorator Pattern. Every message has a reference of preceded message. For newly created message, PsmmFactory puts a RootMessage in it. After a message has been set(\"modified\"), factory create a new message decorating the old one, of course, with new data. Therefore, you can access psmm as if it's mutable.\r\n\r\n####Raw Message and Psmm Factory model:\r\n* **Raw Message** is a concept helper class which is exposed to user instead of factory, and to ensure message is actually created. Consider situation below:\r\n`\t\tUMessage message2 =\r\n\t\t\t\tmessage1\r\n\t\t\t\t.set(key2, 45)  //when first call set(), it turns to a raw message\r\n\t\t\t\t.set(key3, \"this is another string\")\r\n\t\t\t\t.set(key4, 568.3d)\r\n\t\t\t\t//.cook(); //no message is really created.\r\n`\r\n\r\n####Styles\r\nPsmm includes different *Styles of messages standing for different structures.\r\n\r\n1. **Linked**(default): decorate old message when every setting. When getting data, first check keys in newest message, then the last one. This is the fast way to create new object, because when you create it, you don't care about the old data.But when the chain is long, it'll be slower to fetch some data. It also provides a way to regress a message: shell the outermost message, return the inner one.\r\n2. **Flat**: no decoration, read data from old message and merge them into new message.\r\n3. Typed: need to explicitly indicate Generic parameter Type. Thus gives flexibility to put user defined data object into message.\r\n4. **Untyped**: only takes basic immutable object, such as String, Integer etc. When retrieving data, need to cast.\r\n5. **Cached**: references of messages created are stored in a pool. Why not reuse immutable object? (_But there might be a pitfall, is it really necessary to cache small object in modern JVM? I'm working on this issue and refactoring this algorithm. Maybe you can tell me more_.)\r\n6. **Uncached**(default): Oppose to cached.\r\n\r\n_*Style is used for distinguishing from Parameter Type._\r\n\r\nHow to choose style:\r\n`Messages.create(Messages.Style.FLAT_MAP)`\r\n\r\n####Configuration\r\nPsmm provides a class PsmmConfiguration to do some custom setup when initiation.\r\n\r\nHow to setup:\r\n```java\r\n\t\tPsmmConfiguration config=new PsmmConfiguration()\r\n\t\t\t\t\t\t.setMessagePoolSize(6000)\r\n\t\t\t\t\t\t.setFactoryPoolSize(24)\r\n\t\t\t\t\t\t...\r\n\t\tPsmmSystem.initiate(config);\r\n```\r\n\r\n####Performance:\r\nI've prepared some performance test data, and I'll upload them, and explain in detail.\r\n\r\nIt's very important to know that generating message, in most cases, only takes a fraction of application time. It's really not necessary to worry about their performance. When I did micro-benchmark test, yeah, disparity could be huge. However, when I did actual actor interaction test, performances are in the same scale.\r\n\r\n\r\n####Javadoc:\r\nI have written complete javadoc, and I'll  upload it.\r\n\r\n## Support or Contact\r\nAuthors:Cause Chung (@cuzfrog)\r\n\r\nAny problem, please hit on GitHub or mail me: cuzfrog@139.com /cuzfrog@gamil.com\r\n","google":"UA-67181335-1","note":"Don't delete this file! It's used internally to help with page regeneration."}